<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Game of Life Explorer</title>
    <style>
        :root {
            --control-width: 320px;
            --hunter-control-width: 384px; 
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: #f0f0f0;
            padding: 20px;
            gap: 20px;
        }
        #main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-color: #fff;
        }
        
        #all-controls-wrapper {
            display: grid;
            grid-template-columns: var(--control-width) var(--control-width) var(--hunter-control-width);
            gap: 15px;
            align-items: start;
        }
        .control-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group h3, .control-group h4 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        button, select, input {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 14px;
            cursor: pointer;
            box-sizing: border-box;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            margin-bottom: 5px;
        }
        button:last-child { margin-bottom: 0; }
        button:hover { opacity: 0.9; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        
        #palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(25px, 1fr));
            gap: 4px;
        }
        .color-box {
            width: 25px; height: 25px; border: 1px solid #ccc;
            cursor: pointer; border-radius: 4px; transition: transform 0.1s; margin: auto;
            display: flex; justify-content: center; align-items: center; font-size: 10px; color: #555;
        }
        .color-box.active {
            border-color: #000; transform: scale(1.2); box-shadow: 0 0 8px rgba(0,0,0,0.3);
        }
        
        .rule-input-group { margin-bottom: 10px; }
        .rule-input-group label { display: block; margin-bottom: 4px; font-weight: bold; font-size: 13px; }
        .range-container { display: flex; gap: 8px; align-items: center; }
        .range-container span { font-weight: bold; }
        .checkbox-container { display: flex; align-items: center; gap: 8px; margin-top: 8px; }
        .checkbox-container input { width: auto; }
        .checkbox-container label { margin-bottom: 0; font-weight: normal; font-size: 13px; }
        #aging-rules, #hunter-target-group { visibility: hidden; }
        .slider-container { display: flex; align-items: center; gap: 8px; }
        .slider-container input { flex-grow: 1; }

        #rule-hunter-results-container { max-height: 240px; overflow-y: auto; margin-top: 8px; }
        #rule-hunter-results { border-collapse: collapse; width: 100%; font-size: 11px; }
        #rule-hunter-results th, #rule-hunter-results td { border: 1px solid #ddd; padding: 5px; text-align: center; }
        #rule-hunter-results th { background-color: #f2f2f2; }
        #rule-hunter-results button { font-size: 11px; padding: 3px 6px; margin: 0; }
        .highlighted-row td { background-color: #e8f5e9 !important; }
        .button-row { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }

        .checkpoint-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; }
        .checkpoint-row label { flex: 0 0 115px; font-size: 12px; text-align: right; margin-right: 5px; }
        .checkpoint-row input { text-align: center; }
        .checkpoint-row .step-input { flex: 2 1 60px; }
        .checkpoint-row .percent-input { flex: 1 1 50px; }
        .checkpoint-row button { width: 30px; padding: 4px; font-size: 12px; background-color: #f44336; flex-shrink: 0; }
        #add-checkpoint-btn { background-color: #2196F3; margin-top: 5px; }
    </style>
</head>
<body>
    <div id="main-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="all-controls-wrapper">
        <!-- COLUMN 1: Main Controls & Palette -->
        <div class="control-column">
            <div class="control-group">
                <h3>Controls</h3>
                <div class="rule-input-group">
                    <label for="speedSlider">Simulation Speed</label>
                    <div class="slider-container">
                        <input type="range" id="speedSlider" min="0" max="500" value="50" title="Delay between steps in ms. 0 is max speed.">
                        <span id="speedValue">50ms</span>
                    </div>
                </div>
                <button id="startStopBtn" title="Start or stop the simulation">Start</button>
                <button id="stepBtn" title="Advance the simulation by a single step">Step</button>
                <button id="clearBtn" title="Clear the entire grid">Clear</button>
            </div>
            <div class="control-group">
                <h3>Generation</h3>
                <div class="rule-input-group">
                    <label for="densitySlider">Fill Density</label>
                    <div class="slider-container">
                        <input type="range" id="densitySlider" min="1" max="100" value="30" title="The percentage of the grid to be filled with cells.">
                        <span id="densityValue">30%</span>
                    </div>
                </div>
                <button id="randomFillBtn" title="Fill the grid with random cells at the specified density">Random Fill</button>
            </div>
            <div class="control-group">
                <h3>Save / Load State</h3>
                <button id="saveStateBtn" title="Save the current grid state and rules to a file">Save State</button>
                <button id="loadStateBtn" title="Load state from a file">Load State</button>
                <input type="file" id="fileInput" accept=".json" style="display: none;">
            </div>
            <div class="control-group">
                <h3>Palette</h3>
                <div id="palette"></div>
            </div>
        </div>

        <!-- COLUMN 2: Rules -->
        <div class="control-column">
            <div class="control-group">
                <h3>Game Rules</h3>
                <div class="rule-input-group">
                    <label for="ruleTypeSelector">Rule Type:</label>
                    <select id="ruleTypeSelector" title="Choose the cell evolution logic">
                        <option value="NC" title="Новое значение клетки = кол-во живых клеток в квадрате, размер которого зависит от Max Value (3x3, 5x5 или 7x7), включая саму клетку.">1. Neighbor Count</option>
                        <option value="AG">2. Aging</option>
                    </select>
                </div>
                <div class="rule-input-group">
                    <label for="neighborhoodTypeSelector">Neighborhood:</label>
                    <select id="neighborhoodTypeSelector" title="Определяет соседей для правил выживания/рождения (для обоих режимов)">
                        <option value="4_VN">4 Neighbors (Cross)</option>
                        <option value="4_D">4 Neighbors (Diagonal)</option>
                        <option value="8_M" selected>8 Neighbors (Square)</option>
                        <option value="8_XC">8 Neighbors (Large Cross)</option>
                        <option value="8_XD">8 Neighbors (Large Diagonal)</option>
                        <option value="12_C">12 Neighbors (Outer Cross)</option>
                        <option value="12_D">12 Neighbors (Outer Diagonal)</option>
                        <option value="12_R">12 Neighbors (Rings)</option>
                    </select>
                </div>
                <div class="range-container">
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="contributionCapInput">Neighbor Cap:</label>
                        <input type="number" id="contributionCapInput" min="1" max="49" value="9">
                    </div>
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="maxAgeInput">Max Value/Age:</label>
                        <input type="number" id="maxAgeInput" min="2" max="49" value="10">
                    </div>
                </div>
                <div class="rule-input-group">
                    <label>Survival Range (Sum):</label>
                    <div class="range-container">
                        <input type="number" id="minSurviveInput" min="0" value="2">
                        <span>-</span>
                        <input type="number" id="maxSurviveInput" min="0" value="3">
                    </div>
                </div>
                <div class="rule-input-group">
                    <label>Birth Range (Sum):</label>
                    <div class="range-container">
                        <input type="number" id="minBirthInput" min="0" value="3">
                        <span>-</span>
                        <input type="number" id="maxBirthInput" min="0" value="3">
                    </div>
                </div>
                <div id="aging-rules">
                    <div class="checkbox-container">
                        <input type="checkbox" id="reincarnateCheckbox" checked>
                        <label for="reincarnateCheckbox">Reincarnate at max age</label>
                    </div>
                </div>
                <hr style="margin: 10px 0;">
                <h4>Rule Generator</h4>
                <div class="rule-input-group">
                    <label for="generatorTypeSelector">Generator Type:</label>
                    <select id="generatorTypeSelector" title="Choose the rule generation algorithm">
                        <option value="random">1. Standard Random</option>
                        <option value="optimized">2. Optimized (Based on Analysis)</option>
                    </select>
                </div>
                <div class="rule-input-group">
                    <label for="generatorCapMaxInput">Max for Generator (Neighbor Cap):</label>
                    <input type="number" id="generatorCapMaxInput" min="1" max="49" value="9" title="Sets the upper limit for generating 'Max. Neighbor Contribution'.">
                </div>
                <button id="generateRulesBtn" title="Generate new rules and run simulation immediately">Generate & Run</button>
            </div>
        </div>

        <!-- COLUMN 3: Rule Hunter -->
        <div class="control-column">
            <div class="control-group">
                <h3>Rule Hunter</h3>
                <div class="range-container">
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterRuleType">Rule Type:</label>
                        <select id="hunterRuleType">
                            <option value="both">Both</option>
                            <option value="NC">Neighbor Count</option>
                            <option value="AG">Aging</option>
                        </select>
                    </div>
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterGeneratorTypeSelector">Generator:</label>
                        <select id="hunterGeneratorTypeSelector" title="Choose the rule generation algorithm for the hunter">
                            <option value="random">Standard</option>
                            <option value="optimized">Optimized</option>
                        </select>
                    </div>
                </div>
                <div class="range-container">
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterStepsInput">Sim. Steps:</label>
                        <input type="number" id="hunterStepsInput" min="10" value="200">
                    </div>
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterMaxTestsInput">Max Tests:</label>
                        <input type="number" id="hunterMaxTestsInput" min="100" value="1000">
                    </div>
                </div>
                <div class="rule-input-group">
                    <label>Neighborhoods to Test:</label>
                    <div class="checkbox-container" style="justify-content: space-around;">
                        <label><input type="checkbox" id="hunterUse4" checked> 4</label>
                        <label><input type="checkbox" id="hunterUse8" checked> 8</label>
                        <label><input type="checkbox" id="hunterUse12" checked> 12</label>
                    </div>
                </div>
                <div class="rule-input-group">
                    <label>Viability Checkpoints:</label>
                    <div id="hunter-checkpoints-container">
                        <!-- Checkpoints will be dynamically added here -->
                    </div>
                    <button id="add-checkpoint-btn">Add Checkpoint</button>
                </div>
                 <div class="rule-input-group">
                    <label>Max Value/Age Range:</label>
                    <div class="range-container">
                        <input type="number" id="hunterMinMaxAgeInput" min="2" max="49" value="5">
                        <span>-</span>
                        <input type="number" id="hunterMaxMaxAgeInput" min="2" max="49" value="25">
                    </div>
                </div>
                <div class="rule-input-group">
                    <label>Neighbor Cap Range:</label>
                    <div class="range-container">
                        <input type="number" id="hunterMinCapInput" min="1" max="49" value="1">
                        <span>-</span>
                        <input type="number" id="hunterMaxCapInput" min="1" max="49" value="9">
                    </div>
                </div>
                <div class="range-container">
                    <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterGoalSelector">Hunter Goal:</label>
                        <select id="hunterGoalSelector">
                            <option value="maximize">Maximize Diversity</option>
                            <option value="target">Target Diversity</option>
                        </select>
                    </div>
                     <div class="rule-input-group" style="flex: 1;">
                        <label for="hunterResultsLimit">Results Limit:</label>
                        <input type="number" id="hunterResultsLimit" min="1" max="100" value="20">
                    </div>
                </div>
                <div id="hunter-target-group" class="rule-input-group">
                    <label for="hunterTargetDiversityInput">Diversity Target:</label>
                    <input type="number" id="hunterTargetDiversityInput" min="0" value="300">
                </div>
                <p id="hunter-status" style="font-size: 13px; text-align: center; margin: 5px 0;">Ready to hunt.</p>
                <button id="hunterBtn">Start Hunter</button>
                <div id="rule-hunter-results-container">
                    <table id="rule-hunter-results">
                        <thead><tr><th>Type</th><th>Nbrs</th><th>Cap</th><th>Srv</th><th>Brth</th><th>Age</th><th>R?</th><th>Div</th><th>Apply</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div class="button-row" style="margin-top: 10px;">
                    <button id="saveResultsBtn" title="Save hunter settings and results to a file" disabled>Save Results</button>
                    <button id="loadResultsBtn" title="Load hunter results from a file">Load Results</button>
                    <input type="file" id="hunterFileInput" accept=".json" style="display: none;">
                </div>
                <button id="copyResultsBtn" title="Copy hunter settings and results as JSON" disabled>Copy Results</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- CONSTANTS AND SETTINGS ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const cellSize = 10;
    const gridWidth = 60;
    const gridHeight = 60;
    const totalCells = gridWidth * gridHeight;
    canvas.width = gridWidth * cellSize;
    canvas.height = gridHeight * cellSize;

    const colors = [
        '#FFFFFF', '#FF4136', '#FF851B', '#FFDC00', '#2ECC40', '#0074D9', '#B10DC9', '#F012BE', '#7FDBFF', '#3D9970',
        '#01FF70', '#85144b', '#F012BE', '#39CCCC', '#3D9970', '#111111', '#AAAAAA', '#DDDDDD', '#FF6347', '#4682B4',
        '#9ACD32', '#DAA520', '#6A5ACD', '#FF4500', '#2E8B57', '#D2691E', '#DC143C', '#00FFFF', '#00008B', '#B8860B',
        '#006400', '#8B008B', '#FF8C00', '#E9967A', '#8FBC8F', '#483D8B', '#6B8E23', '#556B2F', '#8B4513', '#A0522D',
        '#A52A2A', '#B22222', '#CD5C5C', '#F08080', '#FA8072'
    ];

    const NEIGHBOR_OFFSETS = {
        '4_VN': [[0, -1], [0, 1], [-1, 0], [1, 0]],
        '4_D':  [[-1, -1], [-1, 1], [1, -1], [1, 1]],
        '8_M':  [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]],
        '8_XC': [[-1, 0], [1, 0], [0, -1], [0, 1], [-2, 0], [2, 0], [0, -2], [0, 2]],
        '8_XD': [[-1, -1], [1, 1], [1, -1], [-1, 1], [-2, -2], [2, 2], [2, -2], [-2, 2]],
        '12_C': [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1], [-2, 0], [2, 0], [0, -2], [0, 2]],
        '12_D': [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1], [-2, -2], [2, 2], [-2, 2], [2, -2]],
        '12_R': [[-2, -1], [-2, 0], [-2, 1], [2, -1], [2, 0], [2, 1], [-1, -2], [0, -2], [1, -2], [-1, 2], [0, 2], [1, 2]]
    };

    // --- GAME STATE ---
    let grid = createGrid();
    let isRunning = false;
    let simulationTimeoutId;
    let simulationDelay = 50;
    let currentColor = 1;
    let lastAppliedRule = null;
    
    let rules = {
        type: 'NC', neighborhoodType: '8_M', contributionCap: 9, 
        minSurvive: 2, maxSurvive: 3, minBirth: 3, maxBirth: 3, 
        maxAge: 10, reincarnate: true
    };

    const ui = Object.fromEntries([...document.querySelectorAll('[id]')].map(el => [el.id.replace(/-(\w)/g, (m, p1) => p1.toUpperCase()), el]));
    ui.hunterResultsBody = document.querySelector('#rule-hunter-results tbody');

    function createGrid() { return Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(0)); }
    
    // --- ИЗМЕНЕНИЕ 1: ВСТАВКА УТИЛИТЫ ВЗВЕШЕННОГО ВЫБОРА ---
    function weightedPick(options) {
        // options: [{ v: value, w: weight }, ...]
        const total = options.reduce((s, o) => s + o.w, 0);
        let r = Math.random() * total;
        for (const o of options) {
            r -= o.w;
            if (r <= 0) return o.v;
        }
        return options[options.length - 1].v;
    }

    function drawGrid() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                const cellValue = grid[y][x];
                if (cellValue > 0) {
                    ctx.fillStyle = colors[cellValue] || '#000000';
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }
    }

    function getSpecialNeighborCount(x, y, currentGrid, maxAge) {
        let radius;
        if (maxAge <= 9) {
            radius = 1; // 3x3 square
        } else if (maxAge <= 25) {
            radius = 2; // 5x5 square
        } else {
            radius = 3; // 7x7 square
        }

        let count = 0;
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = (x + dx + gridWidth) % gridWidth;
                const ny = (y + dy + gridHeight) % gridHeight;
                if (currentGrid[ny][nx] > 0) {
                    count++;
                }
            }
        }
        return count;
    }

    function update(currentGrid, currentRules) {
        const newGrid = createGrid();
        const survivalOffsets = NEIGHBOR_OFFSETS[currentRules.neighborhoodType] || NEIGHBOR_OFFSETS['8_M'];

        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let neighborSum = 0;
                for (const [dx, dy] of survivalOffsets) {
                    const nx = (x + dx + gridWidth) % gridWidth;
                    const ny = (y + dy + gridHeight) % gridHeight;
                    const neighborValue = currentGrid[ny][nx];
                    if (neighborValue > 0) {
                        neighborSum += Math.min(neighborValue, currentRules.contributionCap);
                    }
                }

                const currentState = currentGrid[y][x];
                let nextState = 0;
                let isAlive = false;

                if (currentState > 0) {
                    if (neighborSum >= currentRules.minSurvive && neighborSum <= currentRules.maxSurvive) {
                        isAlive = true;
                    }
                } else {
                    if (neighborSum >= currentRules.minBirth && neighborSum <= currentRules.maxBirth) {
                        isAlive = true;
                    }
                }

                if (isAlive) {
                    if (currentRules.type === 'NC') {
                        nextState = getSpecialNeighborCount(x, y, currentGrid, currentRules.maxAge);
                        nextState = Math.min(nextState, currentRules.maxAge);
                        if (nextState === 0) nextState = 1;
                    } else { // 'AG'
                        nextState = (currentState > 0 ? currentState : 0) + 1;
                        if (nextState > currentRules.maxAge) {
                            nextState = currentRules.reincarnate ? 1 : 0;
                        }
                    }
                } else {
                    nextState = 0;
                }
                newGrid[y][x] = nextState;
            }
        }
        return newGrid;
    }

    function gameLoop() {
        if (!isRunning) return;
        grid = update(grid, rules);
        drawGrid();
        simulationTimeoutId = setTimeout(gameLoop, simulationDelay);
    }

    function startSimulation() {
        if (isRunning) return;
        isRunning = true;
        ui.startStopBtn.textContent = 'Stop';
        gameLoop();
    }

    function stopSimulation() {
        if (!isRunning) return;
        isRunning = false;
        clearTimeout(simulationTimeoutId);
        ui.startStopBtn.textContent = 'Start';
    }

    function randomFill(targetGrid, maxVal, densityPercent) {
        const density = densityPercent / 100;
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                targetGrid[y][x] = (Math.random() < density) ? (Math.floor(Math.random() * maxVal) + 1) : 0;
            }
        }
    }

    function applyAndRunNewRules(newRules) {
        stopSimulation();
        Object.assign(rules, newRules);
        updateUIFromRules();
        randomFill(grid, rules.maxAge, parseInt(ui.densitySlider.value, 10));
        drawGrid();
        startSimulation();
    }

    function setupUI() {
        ui.speedSlider.addEventListener('input', (e) => {
            simulationDelay = parseInt(e.target.value, 10);
            ui.speedValue.textContent = `${simulationDelay}ms`;
        });

        ui.ruleTypeSelector.addEventListener('change', (e) => {
            rules.type = e.target.value;
            ui.agingRules.style.visibility = rules.type === 'AG' ? 'visible' : 'hidden';
        });
        
        const ruleInputs = ['neighborhoodType', 'contributionCap', 'minSurvive', 'maxSurvive', 'minBirth', 'maxBirth', 'maxAge'];
        ruleInputs.forEach(key => {
            const inputEl = ui[key + (key.endsWith('Type') ? 'Selector' : 'Input')];
            inputEl.addEventListener('change', () => {
                rules[key] = isNaN(parseInt(inputEl.value, 10)) ? inputEl.value : parseInt(inputEl.value, 10);
                if (key === 'maxAge') updatePalette();
            });
        });
        ui.reincarnateCheckbox.addEventListener('change', () => { rules.reincarnate = ui.reincarnateCheckbox.checked; });

        ui.generateRulesBtn.addEventListener('click', () => {
            const generatorType = ui.generatorTypeSelector.value;
            let newRules;

            if (generatorType === 'optimized') {
                const maxAge = parseInt(ui.maxAgeInput.value, 10);
                const cap = parseInt(ui.contributionCapInput.value, 10);
                const neighborhoodClass = parseInt(ui.neighborhoodTypeSelector.value, 10);
                
                if (![4, 8, 12].includes(neighborhoodClass)) {
                    alert("Optimized generator requires a 4, 8, or 12 neighborhood type to be selected.");
                    return;
                }
                // --- ИЗМЕНЕНИЕ 3: ИЗМЕНЕНИЕ ОБРАБОТЧИКА КНОПКИ "GENERATE & RUN" ---
                const mode = Math.random() < 0.5 ? 'low' : 'high'; // случайный выбор варианта
                newRules = generateRulesOptimizedSmart(maxAge, cap, neighborhoodClass, mode);

            } else { // 'random'
                newRules = generateRules();
                newRules.neighborhoodType = ui.neighborhoodTypeSelector.value;
            }
            
            lastAppliedRule = newRules;
            applyAndRunNewRules(newRules);
        });

        ui.randomFillBtn.addEventListener('click', () => { randomFill(grid, rules.maxAge, parseInt(ui.densitySlider.value, 10)); drawGrid(); });
        ui.densitySlider.addEventListener('input', (e) => { ui.densityValue.textContent = `${e.target.value}%`; });
        
        ui.hunterBtn.addEventListener('click', toggleHunter);
        ui.hunterGoalSelector.addEventListener('change', (e) => {
            ui.hunterTargetGroup.style.visibility = e.target.value === 'target' ? 'visible' : 'hidden';
        });
        ui.copyResultsBtn.addEventListener('click', copyHunterResults);
        ui.saveResultsBtn.addEventListener('click', saveHunterResults);
        ui.loadResultsBtn.addEventListener('click', () => ui.hunterFileInput.click());
        ui.hunterFileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) { loadHunterResults(e.target.files[0]); } });
        
        ui.addCheckpointBtn.addEventListener('click', () => addCheckpointRow());
        ui.hunterStepsInput.addEventListener('change', updateFinalCheckpointStep);
        setupInitialCheckpoints();
    }

    function updateUIFromRules() {
        ui.ruleTypeSelector.value = rules.type;
        ui.neighborhoodTypeSelector.value = rules.neighborhoodType;
        ui.contributionCapInput.value = rules.contributionCap;
        ui.minSurviveInput.value = rules.minSurvive;
        ui.maxSurviveInput.value = rules.maxSurvive;
        ui.minBirthInput.value = rules.minBirth;
        ui.maxBirthInput.value = rules.maxBirth;
        ui.maxAgeInput.value = rules.maxAge;
        ui.reincarnateCheckbox.checked = rules.reincarnate;
        ui.agingRules.style.visibility = rules.type === 'AG' ? 'visible' : 'hidden';
        updatePalette();
    }

    function updatePalette() {
        ui.palette.innerHTML = '';
        const maxPaletteItems = 49;
        for (let i = 1; i <= Math.min(rules.maxAge, maxPaletteItems); i++) {
            const box = document.createElement('div');
            box.className = 'color-box';
            box.style.backgroundColor = colors[i] || '#000';
            box.dataset.color = i;
            box.textContent = i;
            if (i === currentColor) box.classList.add('active');
            box.addEventListener('click', () => {
                currentColor = i;
                updatePalette();
            });
            ui.palette.appendChild(box);
        }
    }

    // --- ИЗМЕНЕНИЕ 2: ЗАМЕНА СТАРОГО ГЕНЕРАТОРА НА ДВЕ НОВЫЕ ФУНКЦИИ И ОБЕРТКУ ---
    
    // Вариант для ВЫСОКОЙ конечной плотности (бывший generateRulesLikeOptimized)
    function generateRulesLikeOptimizedHigh(maxAge, contributionCap, neighborhoods) {
        const neighbors = Number(neighborhoods);
        const neighMap = {
            4: ['4_VN', '4_D'],
            8: ['8_M', '8_XC', '8_XD'],
            12: ['12_C', '12_D', '12_R']
        };
        const allowed = neighMap[neighbors] || neighMap[8];
        const neighborhoodType = allowed[Math.floor(Math.random() * allowed.length)];

        const type = Math.random() < 0.5 ? 'NC' : 'AG';
        const T = Math.max(1, neighbors * contributionCap);

        const bands = {
            "4": {
                "NC": { mb:[0.11,0.18], xb:[0.29,0.37], ms:[0.08,0.15], xs:[0.22,0.32] },
                "AG": { mb:[0.10,0.18], xb:[0.27,0.34], ms:[0.06,0.14], xs:[0.20,0.32] }
            },
            "8": {
                "NC": { mb:[0.13,0.20], xb:[0.32,0.40], ms:[0.03,0.09], xs:[0.20,0.30] },
                "AG": { mb:[0.08,0.14], xb:[0.26,0.33], ms:[0.01,0.04], xs:[0.08,0.12] }
            },
            "12": {
                "NC": { mb:[0.13,0.20], xb:[0.33,0.40], ms:[0.06,0.12], xs:[0.24,0.32] },
                "AG": { mb:[0.07,0.11], xb:[0.26,0.31], ms:[0.01,0.03], xs:[0.08,0.12] }
            }
        };

        const b = bands[String(neighbors)][type];

        function jitter(minF, maxF, k = 0.15) {
            const span = maxF - minF;
            let f = minF + Math.random() * span;
            const shift = (Math.random() - 0.5) * span * k * 2;
            f = Math.min(maxF, Math.max(minF, f + shift));
            return f;
        }
        const pickInt = (minF, maxF) => Math.round(jitter(minF, maxF) * T);
        const clampT = v => Math.max(0, Math.min(v, T));

        let minBirth = pickInt(b.mb[0], b.mb[1]);
        let maxBirth = pickInt(b.xb[0], b.xb[1]);
        let minSurvive = pickInt(b.ms[0], b.ms[1]);
        let maxSurvive = pickInt(b.xs[0], b.xs[1]);

        minBirth = clampT(minBirth);
        maxBirth = clampT(Math.max(maxBirth, minBirth + 1));

        if (maxSurvive > maxBirth) maxSurvive = Math.floor(0.9 * maxBirth);
        if (minSurvive > minBirth) minSurvive = Math.floor(0.9 * minBirth);

        // Ширина окон как было раньше
        if (maxBirth - minBirth < Math.max(2, Math.round(0.08 * T))) {
            maxBirth = clampT(minBirth + Math.max(2, Math.round(0.08 * T)));
        }
        if (maxSurvive - minSurvive < Math.max(2, Math.round(0.06 * T))) {
            maxSurvive = clampT(minSurvive + Math.max(2, Math.round(0.06 * T)));
        }

        return {
            neighborhoodType, contributionCap, minBirth, maxBirth,
            minSurvive, maxSurvive, maxAge,
            reincarnate: Math.random() < 0.5, type
        };
    }

    // Новый вариант для НИЗКОЙ конечной плотности
    function generateRulesLikeOptimizedLow(maxAge, contributionCap, neighborhoods) {
        const neighbors = Number(neighborhoods);

        // Взвешенный выбор конкретного шаблона окрестности
        const weightedNeigh = {
            4: [ {v:'4_VN', w:0.7}, {v:'4_D', w:0.3} ],
            8: [ {v:'8_M', w:0.6}, {v:'8_XD', w:0.25}, {v:'8_XC', w:0.15} ],
            12:[ {v:'12_R', w:0.5}, {v:'12_D', w:0.3}, {v:'12_C', w:0.2} ],
        };
        const neighborhoodType = weightedPick(weightedNeigh[neighbors] || weightedNeigh[8]);

        // Небольшой сдвиг в пользу NC, но AG оставляем заметным
        const pNC = {4:0.65, 8:0.65, 12:0.6}[neighbors] || 0.6;
        const type = Math.random() < pNC ? 'NC' : 'AG';

        const T = Math.max(1, neighbors * contributionCap);

        // Диапазоны как доли от T, выведены из ваших лучших правил при Final Survival < 30%
        const bandsLow = {
            "4": {
                "NC": { mb:[0.10,0.18], xb:[0.16,0.22], ms:[0.06,0.12], xs:[0.14,0.24] },
                "AG": { mb:[0.08,0.14], xb:[0.12,0.18], ms:[0.05,0.10], xs:[0.18,0.26] }
            },
            "8": {
                "NC": { mb:[0.13,0.21], xb:[0.20,0.27], ms:[0.03,0.12], xs:[0.12,0.22] },
                "AG": { mb:[0.12,0.18], xb:[0.18,0.27], ms:[0.02,0.08], xs:[0.10,0.20] }
            },
            "12": {
                "NC": { mb:[0.13,0.21], xb:[0.20,0.32], ms:[0.06,0.20], xs:[0.14,0.34] },
                "AG": { mb:[0.14,0.18], xb:[0.17,0.25], ms:[0.04,0.11], xs:[0.14,0.24] }
            }
        };
        const b = bandsLow[String(neighbors)][type];

        function jitter(minF, maxF, k = 0.15) {
            const span = maxF - minF;
            let f = minF + Math.random() * span;
            const shift = (Math.random() - 0.5) * span * k * 2;
            f = Math.min(maxF, Math.max(minF, f + shift));
            return f;
        }
        const pickInt = (minF, maxF) => Math.round(jitter(minF, maxF) * T);
        const clampT = v => Math.max(0, Math.min(v, T));

        let minBirth = pickInt(b.mb[0], b.mb[1]);
        let maxBirth = pickInt(b.xb[0], b.xb[1]);
        let minSurvive = pickInt(b.ms[0], b.ms[1]);
        let maxSurvive = pickInt(b.xs[0], b.xs[1]);

        // Коррекции и ужесточения под низкую плотность
        minBirth = clampT(minBirth);
        maxBirth = clampT(Math.max(maxBirth, minBirth + (Math.random() < 0.6 ? 1 : 0))); // 40% шанс на равные границы
        if (maxSurvive > maxBirth) maxSurvive = Math.floor(0.95 * maxBirth);
        if (minSurvive > minBirth) minSurvive = Math.floor(0.9 * minBirth);

        // Более мягкие требования к ширине
        const minBW = Math.max(0, Math.round(0.04 * T) - 1); // окна рождения часто узкие
        const minSW = Math.max(0, Math.round(0.02 * T) - 1); // окно выживания еще уже

        if (maxBirth - minBirth < minBW) {
            maxBirth = clampT(minBirth + minBW);
        }
        if (maxSurvive - minSurvive < minSW) {
            maxSurvive = clampT(minSurvive + minSW);
        }

        const pReinc = (type === 'AG')
            ? ({4:0.5, 8:0.7, 12:0.65}[neighbors] || 0.65)
            : 0.5;

        return {
            neighborhoodType, contributionCap, minBirth, maxBirth,
            minSurvive, maxSurvive, maxAge,
            reincarnate: Math.random() < pReinc, type
        };
    }

    // Универсальная обертка-маршрутизатор
    function generateRulesOptimizedSmart(maxAge, contributionCap, neighborhoods, mode = 'auto') {
        if (mode === 'low') return generateRulesLikeOptimizedLow(maxAge, contributionCap, neighborhoods);
        if (mode === 'high') return generateRulesLikeOptimizedHigh(maxAge, contributionCap, neighborhoods);
        // auto: оставим high по умолчанию
        return generateRulesLikeOptimizedHigh(maxAge, contributionCap, neighborhoods);
    }

    function generateRules(forcedType = 'random', ageRange = null, capRange = null, neighborhoodTypes = null) {
        const newRules = {};
        
        if (neighborhoodTypes && neighborhoodTypes.length > 0) {
            newRules.neighborhoodType = neighborhoodTypes[Math.floor(Math.random() * neighborhoodTypes.length)];
        } else {
            newRules.neighborhoodType = '8_M';
        }
        const numNeighbors = NEIGHBOR_OFFSETS[newRules.neighborhoodType].length;

        let cap;
        if (capRange) {
            cap = Math.floor(Math.random() * (capRange.max - capRange.min + 1)) + capRange.min;
        } else {
            const generatorMax = parseInt(ui.generatorCapMaxInput.value, 10);
            cap = Math.floor(Math.random() * generatorMax) + 1;
        }
        
        const maxPossibleSum = numNeighbors * cap;
        const minB = Math.floor(Math.random() * (cap * (numNeighbors / 8 * 3))) + Math.floor(cap * 0.5);
        const maxB = minB + Math.floor(Math.random() * cap * (numNeighbors / 8 * 2));
        const minS = Math.max(1, minB - Math.floor(Math.random() * cap * (numNeighbors / 8 * 1.5)));
        const maxS = minS + Math.floor(Math.random() * cap * (numNeighbors / 8 * 2));

        newRules.contributionCap = cap;
        newRules.minBirth = Math.min(minB, maxPossibleSum);
        newRules.maxBirth = Math.min(maxB, maxPossibleSum);
        newRules.minSurvive = Math.min(minS, maxPossibleSum);
        newRules.maxSurvive = Math.min(maxS, maxPossibleSum);
        
        if (ageRange) {
            newRules.maxAge = Math.floor(Math.random() * (ageRange.max - ageRange.min + 1)) + ageRange.min;
        } else {
            newRules.maxAge = Math.floor(Math.random() * 25) + 5;
        }
        
        newRules.reincarnate = Math.random() > 0.5;
        
        if (forcedType === 'NC' || forcedType === 'AG') {
            newRules.type = forcedType;
        } else {
            newRules.type = Math.random() > 0.5 ? 'AG' : 'NC';
        }
        return newRules;
    }

    let isHunting = false;
    let rulesTestedCount = 0;
    let totalViableRulesFound = 0;
    let foundRules = [];

    function toggleHunter() {
        isHunting = !isHunting;
        if (isHunting) {
            ui.hunterBtn.textContent = 'Stop Hunter';
            rulesTestedCount = 0;
            totalViableRulesFound = 0;
            foundRules = [];
            ui.hunterResultsBody.innerHTML = '';
            ui.copyResultsBtn.disabled = true;
            ui.saveResultsBtn.disabled = true;
            huntForRules();
        } else {
            ui.hunterBtn.textContent = 'Start Hunter';
            ui.hunterStatus.textContent = `Stopped. Found ${totalViableRulesFound} viable rules.`;
        }
    }

    async function huntForRules() {
        if (!isHunting || rulesTestedCount >= parseInt(ui.hunterMaxTestsInput.value, 10)) {
            isHunting = false;
            ui.hunterBtn.textContent = 'Start Hunter';
            ui.hunterStatus.textContent = `Finished. Found ${totalViableRulesFound} viable rules.`;
            if (foundRules.length > 0) {
                ui.copyResultsBtn.disabled = false;
                ui.saveResultsBtn.disabled = false;
            }
            return;
        }

        rulesTestedCount++;
        
        const generatorType = ui.hunterGeneratorTypeSelector.value;
        const ageRange = { min: parseInt(ui.hunterMinMaxAgeInput.value, 10), max: parseInt(ui.hunterMaxMaxAgeInput.value, 10) };
        const capRange = { min: parseInt(ui.hunterMinCapInput.value, 10), max: parseInt(ui.hunterMaxCapInput.value, 10) };
        
        let testRules;

        if (generatorType === 'optimized') {
            const allowedClasses = [];
            if (ui.hunterUse4.checked) allowedClasses.push(4);
            if (ui.hunterUse8.checked) allowedClasses.push(8);
            if (ui.hunterUse12.checked) allowedClasses.push(12);
            
            if (allowedClasses.length === 0) {
                alert("Please select at least one neighborhood class (4, 8, or 12) to test in Rule Hunter.");
                toggleHunter();
                return;
            }

            const neighborhoodClass = allowedClasses[Math.floor(Math.random() * allowedClasses.length)];
            const maxAge = Math.floor(Math.random() * (ageRange.max - ageRange.min + 1)) + ageRange.min;
            const cap = Math.floor(Math.random() * (capRange.max - capRange.min + 1)) + capRange.min;

            // --- ИЗМЕНЕНИЕ 4: ИЗМЕНЕНИЕ ВЕТКИ OPTIMIZED В RULE HUNTER ---
            // Понимаем целевую плотность по последнему чекпоинту
            const checkpoints = getHunterCheckpoints();
            const finalCp = checkpoints.length ? checkpoints[checkpoints.length - 1] : null;
            const mode = (finalCp && finalCp.max < 30) ? 'low' : 'high';

            testRules = generateRulesOptimizedSmart(maxAge, cap, neighborhoodClass, mode);
            
            const forcedType = ui.hunterRuleType.value;
            if (forcedType !== 'both' && testRules.type !== forcedType) {
                 setTimeout(huntForRules, 0);
                 return;
            }

        } else { // 'random'
            const forcedType = ui.hunterRuleType.value;
            const allowedNeighborhoods = [];
            if (ui.hunterUse4.checked) { allowedNeighborhoods.push('4_VN', '4_D'); }
            if (ui.hunterUse8.checked) { allowedNeighborhoods.push('8_M', '8_XC', '8_XD'); }
            if (ui.hunterUse12.checked) { allowedNeighborhoods.push('12_C', '12_D', '12_R'); }
            
            if (allowedNeighborhoods.length === 0) {
                alert("Please select at least one neighborhood type to test in Rule Hunter.");
                toggleHunter();
                return;
            }
            testRules = generateRules(forcedType, ageRange, capRange, allowedNeighborhoods);
        }
        
        let testGrid = createGrid();
        
        const checkpoints = getHunterCheckpoints();
        const initialCheckpoint = checkpoints.find(c => c.step === 0);
        const initialDensity = initialCheckpoint ? (initialCheckpoint.min + initialCheckpoint.max) / 2 : 30;
        
        randomFill(testGrid, testRules.maxAge, initialDensity);

        let isViable = true;
        const simulationSteps = parseInt(ui.hunterStepsInput.value, 10);
        const historyStepsToKeep = 5;
        let gridHistory = [];

        for (let i = 0; i <= simulationSteps; i++) {
            const checkpoint = checkpoints.find(c => c.step === i);
            if (checkpoint) {
                const currentCount = testGrid.flat().filter(cell => cell > 0).length;
                const currentPercentage = (currentCount / totalCells) * 100;
                if (currentPercentage < checkpoint.min || currentPercentage > checkpoint.max) {
                    isViable = false;
                    break;
                }
            }
            
            if (i >= simulationSteps - historyStepsToKeep) {
                gridHistory.push(testGrid.map(row => [...row]));
            }
            
            if (i < simulationSteps) {
                testGrid = update(testGrid, testRules);
            }
        }

        if (isViable) {
            totalViableRulesFound++;
            
            let diversity = 0;
            if (gridHistory.length > 1) {
                const finalGrid = gridHistory[gridHistory.length - 1];
                const diversityScores = [];
                for (let i = 0; i < gridHistory.length - 1; i++) {
                    diversityScores.push(calculateDiversity(gridHistory[i], finalGrid));
                }
                diversity = Math.min(...diversityScores);
            }

            const goal = ui.hunterGoalSelector.value;
            const score = (goal === 'maximize') ? diversity : Math.abs(diversity - parseInt(ui.hunterTargetDiversityInput.value, 10));
            const newEntry = { rule: testRules, diversity: diversity, score: score };
            const resultsLimit = parseInt(ui.hunterResultsLimit.value, 10);

            foundRules.push(newEntry);
            foundRules.sort((a, b) => (goal === 'maximize') ? b.score - a.score : a.score - b.score);
            if (foundRules.length > resultsLimit) foundRules.pop();
            
            redrawHunterTable();
        }
        
        const successRate = rulesTestedCount > 0 ? (totalViableRulesFound / rulesTestedCount * 100).toFixed(2) : 0;
        const worstDiversityInList = foundRules.length > 0 ? foundRules[foundRules.length - 1].diversity.toFixed(0) : 'N/A';
        ui.hunterStatus.innerHTML = `Tested: ${rulesTestedCount} | Found: ${totalViableRulesFound} | Rate: ${successRate}%<br>Worst Div in list: ${worstDiversityInList}`;

        setTimeout(huntForRules, 0);
    }

    function calculateDiversity(gridA, gridB) {
        let differences = 0;
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                if ((gridA[y][x] > 0) !== (gridB[y][x] > 0)) {
                    differences++;
                }
            }
        }
        return differences;
    }

    function redrawHunterTable() {
        ui.hunterResultsBody.innerHTML = '';
        foundRules.forEach(found => {
            const ruleData = found.rule;
            const row = ui.hunterResultsBody.insertRow();
            if (lastAppliedRule && JSON.stringify(ruleData) === JSON.stringify(lastAppliedRule)) {
                row.classList.add('highlighted-row');
            }
            const reincarnateText = ruleData.type === 'AG' ? (ruleData.reincarnate ? 'Y' : 'N') : '—';
            row.innerHTML = `
                <td>${ruleData.type}</td>
                <td>${ruleData.neighborhoodType.replace('_', ' ')}</td>
                <td>${ruleData.contributionCap}</td>
                <td>${ruleData.minSurvive}-${ruleData.maxSurvive}</td>
                <td>${ruleData.minBirth}-${ruleData.maxBirth}</td>
                <td>${ruleData.maxAge}</td>
                <td>${reincarnateText}</td>
                <td>${found.diversity.toFixed(0)}</td>
                <td><button class="apply-rule-btn">Apply</button></td>
            `;
            row.querySelector('.apply-rule-btn').addEventListener('click', () => {
                lastAppliedRule = ruleData;
                applyAndRunNewRules(ruleData);
                redrawHunterTable();
            });
        });
    }

    function setupInitialCheckpoints() {
        ui.hunterCheckpointsContainer.innerHTML = '';
        addCheckpointRow({ step: 0, min: 20, max: 40, label: 'Initial Density %', isFixed: true });
        addCheckpointRow({ step: parseInt(ui.hunterStepsInput.value, 10), min: 5, max: 15, label: 'Final Survival %', isFixed: true });
    }

    function addCheckpointRow(data = {}) {
        const { step = 100, min = 10, max = 20, label, isFixed = false } = data;
        const row = document.createElement('div');
        row.className = 'checkpoint-row';
        
        const labelText = label || `Step:`;
        const stepInputHTML = isFixed 
            ? `<input type="number" class="step-input" value="${step}" readonly title="This value is fixed.">`
            : `<input type="number" class="step-input" value="${step}" min="1" max="${parseInt(ui.hunterStepsInput.value, 10) - 1}">`;
        
        const removeBtnHTML = isFixed ? '' : `<button class="remove-checkpoint-btn" title="Remove checkpoint">-</button>`;

        row.innerHTML = `
            <label>${labelText}</label>
            ${stepInputHTML}
            <input type="number" class="percent-input" value="${min}" min="0" max="100" title="Min %">
            <span>-</span>
            <input type="number" class="percent-input" value="${max}" min="0" max="100" title="Max %">
            ${removeBtnHTML}
        `;

        if (!isFixed) {
            row.querySelector('.remove-checkpoint-btn').addEventListener('click', () => row.remove());
            const lastCheckpointRow = ui.hunterCheckpointsContainer.lastElementChild;
            ui.hunterCheckpointsContainer.insertBefore(row, lastCheckpointRow);
        } else {
            ui.hunterCheckpointsContainer.appendChild(row);
        }
    }

    function updateFinalCheckpointStep() {
        const finalStepInput = ui.hunterCheckpointsContainer.lastElementChild.querySelector('.step-input');
        if (finalStepInput) {
            finalStepInput.value = ui.hunterStepsInput.value;
        }
    }

    function getHunterCheckpoints() {
        const checkpoints = [];
        document.querySelectorAll('#hunter-checkpoints-container .checkpoint-row').forEach(row => {
            const inputs = row.querySelectorAll('input[type="number"]');
            checkpoints.push({
                step: parseInt(inputs[0].value, 10),
                min: parseInt(inputs[1].value, 10),
                max: parseInt(inputs[2].value, 10)
            });
        });
        return checkpoints;
    }

    function getHunterDataAsObject() {
        const hunterSettings = {
            simulationSteps: parseInt(ui.hunterStepsInput.value, 10),
            maxTests: parseInt(ui.hunterMaxTestsInput.value, 10),
            checkpoints: getHunterCheckpoints(),
            use4: ui.hunterUse4.checked, use8: ui.hunterUse8.checked, use12: ui.hunterUse12.checked,
            minMaxAge: parseInt(ui.hunterMinMaxAgeInput.value, 10),
            maxMaxAge: parseInt(ui.hunterMaxMaxAgeInput.value, 10),
            minCap: parseInt(ui.hunterMinCapInput.value, 10),
            maxCap: parseInt(ui.hunterMaxCapInput.value, 10),
            hunterGoal: ui.hunterGoalSelector.value,
            targetDiversity: parseInt(ui.hunterTargetDiversityInput.value, 10),
            ruleTypeFilter: ui.hunterRuleType.value,
            resultsLimit: parseInt(ui.hunterResultsLimit.value, 10),
        };
        return { settings: hunterSettings, results: foundRules };
    }

    function copyHunterResults() {
        const dataToCopy = getHunterDataAsObject();
        navigator.clipboard.writeText(JSON.stringify(dataToCopy, null, 2)).then(() => {
            const originalText = ui.copyResultsBtn.textContent;
            ui.copyResultsBtn.textContent = 'Copied!';
            setTimeout(() => { ui.copyResultsBtn.textContent = originalText; }, 2000);
        });
    }

    function saveHunterResults() {
        const dataToSave = getHunterDataAsObject();
        const blob = new Blob([JSON.stringify(dataToSave, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `gol_hunter_results_${new Date().toISOString().slice(0,19).replace('T','_').replace(/:/g,'-')}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function loadHunterResults(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (!data.settings || !data.results) throw new Error('Invalid hunter results file format.');
                
                const s = data.settings;
                ui.hunterStepsInput.value = s.simulationSteps || 200;
                ui.hunterMaxTestsInput.value = s.maxTests || 1000;
                ui.hunterUse4.checked = s.use4 !== false;
                ui.hunterUse8.checked = s.use8 !== false;
                ui.hunterUse12.checked = s.use12 !== false;
                ui.hunterMinMaxAgeInput.value = s.minMaxAge || 5;
                ui.hunterMaxMaxAgeInput.value = s.maxMaxAge || 25;
                ui.hunterMinCapInput.value = s.minCap || 1;
                ui.hunterMaxCapInput.value = s.maxCap || 9;
                ui.hunterGoalSelector.value = s.hunterGoal || 'maximize';
                ui.hunterTargetDiversityInput.value = s.targetDiversity || 300;
                ui.hunterRuleType.value = s.ruleTypeFilter || 'both';
                ui.hunterResultsLimit.value = s.resultsLimit || 20;
                ui.hunterTargetGroup.style.visibility = ui.hunterGoalSelector.value === 'target' ? 'visible' : 'hidden';

                ui.hunterCheckpointsContainer.innerHTML = '';
                if (s.checkpoints && s.checkpoints.length > 0) {
                    s.checkpoints.forEach((cp, index) => {
                        const isFirst = index === 0 && cp.step === 0;
                        const isLast = index === s.checkpoints.length - 1 && cp.step == ui.hunterStepsInput.value;
                        addCheckpointRow({
                            step: cp.step, min: cp.min, max: cp.max,
                            label: isFirst ? 'Initial Density %' : (isLast ? 'Final Survival %' : 'Step:'),
                            isFixed: isFirst || isLast
                        });
                    });
                } else {
                    setupInitialCheckpoints();
                }

                foundRules = data.results;
                redrawHunterTable();
                ui.copyResultsBtn.disabled = false;
                ui.saveResultsBtn.disabled = false;
                alert('Hunter results loaded successfully!');
            } catch (error) {
                alert('Error reading file: ' + error.message);
            }
        };
        reader.readAsText(file);
    }

    function valueToChar(v) { return v < 36 ? v.toString(36) : '0'; }
    function charToValue(c) { return parseInt(c, 36); }

    function saveState() {
        const gridString = grid.flat().map(valueToChar).join('');
        const state = { rules, grid: gridString, gridWidth, gridHeight };
        const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `gol_state_${new Date().toISOString().slice(0,19).replace('T','_').replace(/:/g,'-')}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function loadState(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const state = JSON.parse(e.target.result);
                if (!state.rules || !state.grid || state.gridWidth !== gridWidth || state.gridHeight !== gridHeight) {
                    throw new Error('Invalid file format or grid dimensions do not match.');
                }
                Object.assign(rules, state.rules);
                updateUIFromRules();
                let index = 0;
                for (let y = 0; y < gridHeight; y++) {
                    for (let x = 0; x < gridWidth; x++) {
                        grid[y][x] = charToValue(state.grid[index++]);
                    }
                }
                drawGrid();
                alert('State loaded successfully!');
            } catch (error) {
                alert('Error reading file: ' + error.message);
            }
        };
        reader.readAsText(file);
    }

    ui.startStopBtn.addEventListener('click', () => { isRunning ? stopSimulation() : startSimulation(); });
    ui.stepBtn.addEventListener('click', () => { if (!isRunning) { grid = update(grid, rules); drawGrid(); } });
    ui.clearBtn.addEventListener('click', () => { grid = createGrid(); drawGrid(); });
    
    ui.saveStateBtn.addEventListener('click', saveState);
    ui.loadStateBtn.addEventListener('click', () => ui.fileInput.click());
    ui.fileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) { loadState(e.target.files[0]); } });

    canvas.addEventListener('click', (e) => {
        if (isRunning) return;
        const rect = canvas.getBoundingClientRect();
        const x = Math.floor((e.clientX - rect.left) / cellSize);
        const y = Math.floor((e.clientY - rect.top) / cellSize);
        if (x >= 0 && x < gridWidth && y >= 0 && y < gridHeight) {
            grid[y][x] = grid[y][x] > 0 ? 0 : currentColor;
            drawGrid();
        }
    });

    setupUI();
    updateUIFromRules();
    drawGrid();
});
</script>
</body>
</html>